# scanners/software_scanner.py
import subprocess
import re
import platform
from packaging import version

class SoftwareScanner:
    def __init__(self, target):
        self.target = target
        self.os_type = platform.system().lower()
        self.software_db = {
            "apache2": {"safe_version": "2.4.54", "vuln": "CVE-2022-31813", "check_command": "apache2 -v"},
            "nginx": {"safe_version": "1.23.3", "vuln": "CVE-2021-23017", "check_command": "nginx -v"},
            "mysql": {"safe_version": "8.0.31", "vuln": "CVE-2022-21587", "check_command": "mysql --version"},
            "php": {"safe_version": "8.1.13", "vuln": "CVE-2022-31629", "check_command": "php -v"},
            "python": {"safe_version": "3.9.13", "vuln": "CVE-2022-37454", "check_command": "python --version"},
            "node": {"safe_version": "18.12.1", "vuln": "CVE-2022-3602", "check_command": "node --version"},
            "openssl": {"safe_version": "1.1.1", "vuln": "CVE-2022-3602", "check_command": "openssl version"},
            "postgresql": {"safe_version": "15.1", "vuln": "CVE-2022-41862", "check_command": "psql --version"}
        }

    def run_command(self, command):
        try:
            result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
            return result.stdout
        except subprocess.CalledProcessError as e:
            return f"Error running command: {e}"
        except Exception as e:
            return f"Unexpected error: {e}"

    def get_software_version(self, software):
        command = self.software_db[software]["check_command"]
        output = self.run_command(command)
        
        version_patterns = {
            "apache2": r"Apache/([\d.]+)",
            "nginx": r"nginx/([\d.]+)",
            "mysql": r"mysql\s+Ver\s+([\d.]+)",
            "php": r"PHP ([\d.]+)",
            "python": r"Python ([\d.]+)",
            "node": r"v([\d.]+)",
            "openssl": r"OpenSSL ([\d.]+\w*)",
            "postgresql": r"psql \(PostgreSQL\) ([\d.]+)"
        }
        
        if software in version_patterns:
            match = re.search(version_patterns[software], output)
            if match:
                return match.group(1)
        return None

    def check_os_version(self):
        if self.os_type == "linux":
            return self.check_linux_version()
        elif self.os_type == "windows":
            return self.check_windows_version()
        elif self.os_type == "darwin":
            return self.check_macos_version()
        else:
            return f"Unsupported OS: {self.os_type}"

    def check_linux_version(self):
        kernel_version = self.run_command("uname -r").strip()
        distro_info = self.run_command("cat /etc/os-release")
        return f"Kernel: {kernel_version}\nDistro Info:\n{distro_info}"

    def check_windows_version(self):
        return self.run_command("ver")

    def check_macos_version(self):
        return self.run_command("sw_vers")

    def compare_versions(self, installed_version, safe_version):
        try:
            return version.parse(installed_version) < version.parse(safe_version)
        except version.InvalidVersion:
            # If parsing fails, fall back to simple string comparison
            return installed_version.split('.') < safe_version.split('.')

    def check_vulnerabilities(self):
        vulnerabilities = []
        
        # Check OS version
        os_version = self.check_os_version()
        vulnerabilities.append({
            "type": "OS Information",
            "tool": "OS Version Check",
            "details": os_version,
            "severity": "Info"
        })
        
        # Check software versions
        for software, info in self.software_db.items():
            installed_version = self.get_software_version(software)
            if installed_version:
                if self.compare_versions(installed_version, info["safe_version"]):
                    vuln = {
                        "type": "Software Vulnerability",
                        "tool": "Software Version Check",
                        "software": software,
                        "installed_version": installed_version,
                        "safe_version": info["safe_version"],
                        "details": f"Vulnerable to {info['vuln']}",
                        "severity": "High"
                    }
                    vulnerabilities.append(vuln)
                else:
                    print(f"{software} version {installed_version} is up to date.")
            else:
                print(f"{software} not found or version check failed.")
        
        return vulnerabilities

    def scan(self):
        print("Checking OS and installed software versions...")
        return self.check_vulnerabilities()
